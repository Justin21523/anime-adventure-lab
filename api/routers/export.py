# api/routers/export.py
from fastapi import APIRouter, HTTPException, UploadFile, File
from fastapi.responses import FileResponse
from typing import Dict, Any, Optional, List
from pydantic import BaseModel
import json
from pathlib import Path
from datetime import datetime

import sys
from pathlib import Path

ROOT_DIR = Path(__file__).resolve().parent.parent
sys.path.append(str(ROOT_DIR))
sys.path.append("../..")

from core.export.story_exporter import (
    StoryExporter,
    ExportConfig,
    StorySession,
    StoryTurn,
)

router = APIRouter(prefix="/export", tags=["export"])


class ExportRequest(BaseModel):
    session_id: str
    format: str = "html"  # html, pdf, json, archive
    include_images: bool = True
    include_metadata: bool = True
    watermark_text: Optional[str] = None


class StoryTurnRequest(BaseModel):
    turn_id: int
    user_input: str
    narration: str
    dialogues: List[Dict[str, str]] = []
    choices: List[str] = []
    selected_choice: Optional[str] = None
    background_image: Optional[str] = None
    character_image: Optional[str] = None
    metadata: Dict[str, Any] = {}


class StorySessionRequest(BaseModel):
    session_id: str
    title: str
    world_id: str
    character_name: str
    turns: List[StoryTurnRequest]
    metadata: Dict[str, Any] = {}


@router.post("/story")
async def export_story(request: ExportRequest):
    """Export story session to specified format"""

    # Create exporter config
    config = ExportConfig(
        include_images=request.include_images,
        include_metadata=request.include_metadata,
        watermark_text=request.watermark_text or "Generated by SagaForge",
    )

    exporter = StoryExporter(config)

    # For now, we'll create a sample story
    # In real implementation, this would load from database
    sample_story = _create_sample_story(request.session_id)

    try:
        if request.format == "json":
            export_path = exporter.export_to_json(sample_story)
        elif request.format == "html":
            export_path = exporter.export_to_html(sample_story)
        elif request.format == "pdf":
            export_path = exporter.export_to_pdf(sample_story)
        elif request.format == "archive":
            export_path = exporter.create_story_archive(sample_story)
        else:
            raise HTTPException(
                status_code=400, detail=f"Unsupported format: {request.format}"
            )

        return {
            "status": "success",
            "export_path": export_path,
            "format": request.format,
            "file_size_mb": Path(export_path).stat().st_size / 1024**2,
            "exported_at": datetime.now().isoformat(),
        }

    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Export failed: {str(e)}")


@router.get("/story/{session_id}/download")
async def download_exported_story(session_id: str, format: str = "html"):
    """Download exported story file"""

    export_dir = Path("../ai_warehouse/outputs/exports")

    if format == "archive":
        file_path = export_dir / f"{session_id}_complete.zip"
        media_type = "application/zip"
    elif format == "pdf":
        file_path = export_dir / f"{session_id}_story.pdf"
        media_type = "application/pdf"
    elif format == "html":
        file_path = export_dir / f"{session_id}_story.html"
        media_type = "text/html"
    elif format == "json":
        file_path = export_dir / f"{session_id}_story.json"
        media_type = "application/json"
    else:
        raise HTTPException(status_code=400, detail=f"Unsupported format: {format}")

    if not file_path.exists():
        raise HTTPException(
            status_code=404, detail=f"Export file not found: {file_path}"
        )

    return FileResponse(
        path=str(file_path), media_type=media_type, filename=file_path.name
    )


@router.post("/story/upload")
async def upload_story_session(story: StorySessionRequest):
    """Upload and export a custom story session"""

    # Convert request to internal format
    turns = []
    for turn_req in story.turns:
        turn = StoryTurn(
            turn_id=turn_req.turn_id,
            user_input=turn_req.user_input,
            narration=turn_req.narration,
            dialogues=turn_req.dialogues,
            choices=turn_req.choices,
            selected_choice=turn_req.selected_choice,
            background_image=turn_req.background_image,
            character_image=turn_req.character_image,
            timestamp=datetime.now().isoformat(),
            metadata=turn_req.metadata,
        )
        turns.append(turn)

    story_session = StorySession(
        session_id=story.session_id,
        title=story.title,
        world_id=story.world_id,
        character_name=story.character_name,
        turns=turns,
        start_time=datetime.now().isoformat(),
        end_time=None,
        total_turns=len(turns),
        metadata=story.metadata,
    )

    # Export to all formats
    config = ExportConfig()
    exporter = StoryExporter(config)

    results = {}
    try:
        results["json"] = exporter.export_to_json(story_session)
        results["html"] = exporter.export_to_html(story_session)
        # results["pdf"] = exporter.export_to_pdf(story_session)  # May fail without weasyprint
        results["archive"] = exporter.create_story_archive(story_session)
    except Exception as e:
        results["error"] = str(e)

    return {
        "status": "success",
        "session_id": story.session_id,
        "exports": results,
        "uploaded_at": datetime.now().isoformat(),
    }


@router.post("/story/import")
async def import_story_from_json(file: UploadFile = File(...)):
    """Import story from JSON export file"""

    if not file.filename.endswith(".json"):
        raise HTTPException(status_code=400, detail="Only JSON files are supported")

    try:
        content = await file.read()
        data = json.loads(content.decode("utf-8"))

        # Validate format
        if data.get("format") != "SagaForge Story Export v1.0":
            raise HTTPException(status_code=400, detail="Invalid export format")

        # Load story
        config = ExportConfig()
        exporter = StoryExporter(config)

        # Save temp file and load
        temp_path = Path("../ai_warehouse/outputs/exports") / f"temp_{file.filename}"
        with open(temp_path, "w", encoding="utf-8") as f:
            json.dump(data, f, ensure_ascii=False, indent=2)

        story = exporter.load_from_json(str(temp_path))
        temp_path.unlink()  # Clean up

        return {
            "status": "success",
            "story": {
                "session_id": story.session_id,
                "title": story.title,
                "world_id": story.world_id,
                "character_name": story.character_name,
                "total_turns": story.total_turns,
                "start_time": story.start_time,
            },
            "imported_at": datetime.now().isoformat(),
        }

    except json.JSONDecodeError:
        raise HTTPException(status_code=400, detail="Invalid JSON file")
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Import failed: {str(e)}")


@router.get("/formats")
def get_supported_formats():
    """Get list of supported export formats"""
    return {
        "formats": [
            {
                "id": "html",
                "name": "HTML Interactive",
                "description": "Interactive HTML with images and styling",
                "supports_images": True,
                "file_extension": ".html",
            },
            {
                "id": "json",
                "name": "JSON Data",
                "description": "Machine-readable story data",
                "supports_images": False,
                "file_extension": ".json",
            },
            {
                "id": "pdf",
                "name": "PDF Document",
                "description": "Printable PDF with manga-style layout",
                "supports_images": True,
                "file_extension": ".pdf",
                "requires": ["weasyprint"],
            },
            {
                "id": "archive",
                "name": "Complete Archive",
                "description": "ZIP archive with all formats and images",
                "supports_images": True,
                "file_extension": ".zip",
            },
        ]
    }


def _create_sample_story(session_id: str) -> StorySession:
    """Create a sample story for testing"""

    turns = [
        StoryTurn(
            turn_id=1,
            user_input="我想探索這個神秘的森林",
            narration="你踏入了一片茂密的森林，陽光透過樹葉灑下斑駁的光影。遠處傳來潺潺的流水聲，空氣中瀰漫著青草和花香的味道。",
            dialogues=[
                {"character": "精靈嚮導", "text": "歡迎來到翡翠森林，勇敢的冒險者。"}
            ],
            choices=["跟隨嚮導深入森林", "獨自探索小徑", "尋找水源"],
            selected_choice="跟隨嚮導深入森林",
            background_image=None,
            character_image=None,
            timestamp=datetime.now().isoformat(),
            metadata={"mood": "mysterious", "location": "forest_entrance"},
        ),
        StoryTurn(
            turn_id=2,
            user_input="跟隨嚮導深入森林",
            narration="精靈嚮導輕盈地在前方帶路，她的腳步幾乎沒有發出任何聲音。你們來到了一片空地，中央有一顆巨大的古樹，樹幹上刻著古老的符文。",
            dialogues=[
                {"character": "精靈嚮導", "text": "這是智慧之樹，它擁有千年的記憶。"},
                {"character": "你", "text": "這些符文代表什麼意思？"},
            ],
            choices=["觸摸古樹", "詢問符文的含義", "四處查看"],
            selected_choice="詢問符文的含義",
            background_image=None,
            character_image=None,
            timestamp=datetime.now().isoformat(),
            metadata={"mood": "wonder", "location": "wisdom_tree"},
        ),
    ]

    return StorySession(
        session_id=session_id,
        title="翡翠森林的冒險",
        world_id="emerald_forest",
        character_name="新手冒險者",
        turns=turns,
        start_time=datetime.now().isoformat(),
        end_time=None,
        total_turns=len(turns),
        metadata={"theme": "fantasy", "difficulty": "beginner"},
    )
